<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>


!!!        БАГ С НАЖАТИЕМ НА INPUT А ВЫБИРАЕТЬСЯ ДРУГОЙ INPUT В materialize.css
<!--
  Все из за того что везде указан одинаковый id для label который ссыылаеться на input.
  Нужно установить разный id для каждого input
-->
<div class="input-field col s12">
  <input @keypress="v$.repeatPassword.$validate()" v-model="repeatPassword" id="repeatPassword" type="password"
   :class="{invalid: v$.repeatPassword.$error, validate: !v$.repeatPassword.$error}"
  >
  <label for="repeatPassword">Reset Password</label>
  <span class="helper-text" data-error="Вы ничего не ввели" data-success="right"></span>
</div>





!!! КАК ЛЕГКО И БЫСТРО ПЕРЕВОДИТЬ В СОСТОЯНИЯ true или false какойто обект ?
<blockquote>
  Переключатель {{ $store.state.toggle }}
</blockquote>
<div class="switch">
  <label>
    Off
    <!-- Спомощю такого алгоритма - логическое значения в ключе toggle изменяеться 
    то на true то на false -->
    <input @click="$store.state.toggle = !$store.state.toggle" type="checkbox" >
    <span class="lever"></span>
    On
  </label>  


!!! КАК НАПИСАТЬ УСЛОВИЯ СПОМОЩЮ ДИРЕКТИВЫ v-bind В АТРИБУТЕ href
<!--
  Можна записать условием выбор строк, когда речь идет о ссылке,
  например если мы создаем ссылки циклом и нам нужно чтобе там 
  записался нужный нам index то можна это все записать спомощю тернарного оператора
-->
<template>
  <div class="navigation">
    <div v-for="(elem,index) of $store.state.nav" :key="index" class="navigation__page">
      <a :href="[index == 0 ? `/#/` : `/#/${index}`]"> {{ index+ 1 }} </a>
    </div>
  </div>
</template>


  !!!! ВНИМАНИЕ: Если мы хотим чтобе текущие стили были видны только в текущем
  компоненте то в тег style scoped> нужно прописать


  !!!! ВНИМАНИЕ: Как установить препроцессор less ?
  - npm install -D less less-loader
  
  <style lang="less">
    /* Выставляем после чего в стилях lang="less" */
  </style>

  

      ИЗУЧЕНИЯ VUE (ТАКЖЕ НУЖНО УСТАНОВИТЬ ПРЕПРОЦЕССОР LESS, ОБ ЭТОМ РАСКАЗАНО ВЫШЕ)

  <!--
    Создания проекта и запуск сервера -
    (обязательно пишем со скобками, и это прописываем если не установлен vue cli глобально на компютер)
    npm install -g "@vue/cli"
    vue create
    (запуск самого сервера)
    npm run serve
  -->











   !!!!!     Cоздания и добавления компонентов

   <!--
     1. В папке components создать файл с разширениям .vue
     ВНИМАНИЕ: Имя должно быть из двух слов, каждое с которых начинаеться
     с большой буквы
     2. Содержимое файла должно быть обернуто в <template>
     3. В основном файле App.vue импортировать компонент
      import TodoList from '@/components/TodoList.vue'
     4. В обект components добавить названия импортируемого компонента
     5. А также добавить наш компонент <TodoList/> в html шаблон в 
     файде App.vue в теге <template> 
   -->     


   <!-- Файл TodoList.vue -->
   <template>
    <div>Это новый компонент</div>
   </template>


   <!-- Файл App.vue -->
   <template>
    <div id="app">
      <TodoList/>
    </div>
  </template>
  
  <script>
    import TodoList from '@/components/TodoList.vue'
    export default {
      name: 'App',
      components: {
        TodoList
      }
    }
  </script>

  <!-- 
    Теперь мы можем  вставлять шаблоны компонентов как переменные в виде 
    тегов в наш основной html шаблон. Это очень удобно, понятно и быстро
    использовать если проект писать.
   -->












   !!!!!!          Компонент вложенный в другой компонент

   <!--
     1. Создаем новый файл TwoCom.vue в папке components
     2. Пишем свой шааблон в файле TwoCom.vue
     3. В файле TodoList.vue создаем тег script в котором
     import twoItem from "@/components/TwoCom.vue";
       export default {
          components: {
            twoItem
          }
        }
     4. Теперь у нас компонент TwoCom.vue выводиться в компоненте TodoList.vue который
     выводиться в файле App.vue в нашем основном шаблоне   
   -->

  <!-- Файл TwoCom.vue -->
  <template>
    <div class="div">Компонент вложенный в компонент</div>
  </template>


   <!-- Файл TodoList.vue -->
   <template>
    <div>Это новый компонент</div>
    <two-item/>
  </template>
  
  <script>
    import twoItem from "@/components/TwoCom.vue";
    /*
    export default {
      components: {
        twoItem
      }
    }
    */
  </script>

  <!--  
    Таким образом мы можем делать бесконечное вложения в шаблон другого шаблона
    что также ооочень удобно в плане разработки
  -->















   !!!!!!   Перебор елементов массива


  <!--
    1. Для этого в обектов export.default создаем функцию date с содержимой
    в ней инфой 
      data(){
          return {
            todos: [
              {text: `Огги и кукарачи`},
              {text: `Рапунсель спусти косу`},
              {text: `Я не я и хата не моя`}
            ]
          }
        }
    2. Если мы хотим передать информацию в компонент TodoList то делаим это так
    <TodoList
      v-bind:kek="todos"
    /> 
    3. В нашем файле TodoList.vue принимаем информацию вот так
      export default {
        props: ["kek"],
        components: {
          twoItem
        }
      }
    4. А чтобе итерировать обекты в цикле то делаим так 
     <div v-for="item of kek" :key="item.text">
        {{item.text}}
      </div>  
  --> 
  
  
  <!-- Содержимое файла TodoList.vue -->
  <template >
    <div v-for="item of kek" :key="item.text">
      {{item.text}}
    </div>
    <two-item/>
  </template>
  
  <script>
  /*
    import twoItem from "@/components/TwoCom.vue";
    export default {
      props: ["kek"],
      components: {
        twoItem
      }
    }
    */
  </script>

  <!-- Содержимое обекта default в файле App.vue -->

  <template>
    <div id="app">
      <h1>Привет</h1>
  
      <TodoList
        v-bind:kek="todos"
      />
    </div>
  </template>
  <script>
      /*
      import TodoList from '@/components/TodoList.vue'
    export default {
      name: 'App',
      data(){
        return {
          todos: [
            {text: `Огги и кукарачи`},
            {text: `Рапунсель спусти косу`},
            {text: `Я не я и хата не моя`}
          ]
        }
      },
      components: {
        TodoList
      }
    }
    */
   </script>












  !!!                  ИНТЕРПОЛЯЦИЯ

  Это короче когда указывая индекс обекта в массиве мы можем вывести его Содержимое
  <script>
    // Вот допустим в массиве у нас есть обекты
    [
      {
        name: `Вася`
      }
    ]
  </script>
  Чтобе вывести нужный нам обект из массива - нужно указать его индекс сперва
  <div class="test">
    {{infa[0].name}}
  </div>



















!!!                 Работа с классами и стилями + Обработка событий
                              v-bind:class и v-on

Часто возникает необходимость динамически изменять CSS-классы, или добавлять
, удалять или редактировать. Спомощю Vue.js это стане еще проще в раз так 10

<script>
  // НАША БАЗА ДАННЫХ
 let exportDefault = {
  data(){
    return {
      inform:[
        {
          name: `Володя`,
          age: `17 лет`,
          city: `Москва`,
          completed: false
        },
        {
          name: `Артем`,
          age: `12 лет`,
          city: `Днепр`,
          completed: false
        },        
        {
          name: `Шашлик`,
          age: `23 лет`,
          city: `Паска`,
          completed: false
        },        
      ]
    }
  }
 }
</script>

<!--
  Для динамической установки или удаления CSS-классов можно передавать объект
  в директиву v-bind:class.
-->
<template>
  <div v-for="item of infa" :key="item.name" class="app__tables__table">
    <span v-bind:class="{active: item.completed}">
      <!--
        Запись выше означает, что наличие класса active будет определяться
        истинностью параметра completed. Если completed = true то клас
        active добавляеться в наш span, а если false то убераеться
      -->
      Имя:   {{item.name}} <br/>
      Возраст:  {{item.age}} <br/>
      Город:  {{item.city}}
      <!--
        Для подписки на события DOM и выполнения JavaScript-кода по их 
        наступлении используйте директиву v-on.

        Например:
        <button v-on:click="counter += 1">+1</button>
        <p>Кнопка выше была нажата {{ counter }} раз</p>

        Таким образом мы динамически изменяем переменную counter в нашем абзацце
        а также число в нашем обекте всеголиш одной маленькой строкой

        Или можна написать сокращенно @click="counter += 1"
      -->
      <input type="checkbox" v-on:change="item.completed = !item.completed">
    </span>
  </div>    
</template>

























!!!     Прослушивания событий дочерних елементов и обект methods

  Создания событий в дочерних компонентах и передача срабатывания этих 
  событий родительскому компоненту



    <!-- Дочерний файл компонента нашего родительского елемента-->  
    <template>
      <span v-for="item of infa" :key="item.name">
        <!--
          Для того что сообщить родительскому компонентку что у нас чтото случилось
          - мы обращаемся к функции $emit() где первый параметром мы указываем 
          название события (придумываем самостоятельно), вторым параметром мы 
          передаем нашы данные
          -->
        <button @click="$emit(`remove-todo`, item.age)">Кпнока</button>
      </span>
    </template>  
    <script>
      /*
      export default {
        props: [`infa`],
        components: {
        
        }
      }
      */
    </script>



    <!-- Родительский компонент -->
    <template>
      <div id="app">
        <div class="app__tables">
          <!--
            Здесь мы прослушиваем метод 
             @remove-todo и в нем визиваем функцию testM() если
             сработает события
          -->
          <FastFood
            v-bind:infa="inform"
        
            @remove-todo="testM"
          />
        </div>
      </div>
    </template>
    <script>

      import FastFood from "@/components/BaseKek.vue"
      /*
        export default {
          name: 'App',
          data(){
            return {
              inform:[
                {
                  name: `Володя`,
                  age: `17 лет`,
                  city: `Москва`,
                  completed: false
                },
                {
                  name: `Артем`,
                  age: `12 лет`,
                  city: `Днепр`,
                  completed: false
                },        
                {
                  name: `Шашлик`,
                  age: `23 лет`,
                  city: `Паска`,
                  completed: false
                },        
              ]
            }
          },
          components: {
            FastFood
          },
          methods: {
            testM(elem){
              console.log(`Сработало прослушивания события дочернего елемента ${elem}`);
            }
          }
        }
     */
     </script>



















   !!!!         События формы @submit и считывания данных формы

   Во vue.js можна легко и просто отследить когда мы отправляем чтото из формы 
   а также отменить перезагрузки страницы при отправке формы

  <!-- Компонент TheForm.vue -->
  <template>
    <!--
      @submit - это такоеже события как и @click или @change 
      .prevent - значит что мы отменяет перезагрузку страницы после отправки формы
    -->
    <form @submit.prevent="fromAction">
      <!-- v-model это короче ссылка на ключь в который мы будем записывать данные при отправке формы -->
      <input type="text" v-model="title">
      <button type="submit">Отправить</button>
    </form>
  </template>

  <script>
    /*
     {
      data(){
        return {
          В этот ключь мы будем записывать данные с нашего input
          title: ``
        }
      },
      methods: {
        fromAction(){
          console.log(`Нажато на форму + ${this.title}`)
        }
      }
    }
    */
  </script>
















!!!           Добавления данных из компонента в основую базу данных

  <!-- Содержимое компонента TheForm.vue -->

  <template>
    <form @submit.prevent="fromAction">
      <input type="text" v-model="title">
      <button type="submit">Отправить</button>
    </form>
  </template>

  <!-- Я создаю новый обект в котором делаю нужные мне ключи 
    и отправка созданного обекта родительскому компоненту
  -->
  <script>
    /*
    export default {
      data(){
        return {
          title: ``
        }
      },
      methods: {
        fromAction(){
          if(this.title.trim()){
            let tab = {
              description: this.title,
              open: false
            }
            this.$emit(`addTab`, tab);
          }
        }
      }
    }
  */
  </script>

  <!-- Содержимое компонента App.vue -->

  <template>
    <div id="app">
      <Form
        @addTab="addTab"
      />
   
  
    </div>
  </template>
  
  <script>
  
  /*
  import Form from "@/components/TheForm.vue"
  export default {
    name: 'App',
    data(){
      return {
        tabs: [
          {
            description: `Клавиатура не умеет бегать`,
            open: false
          },
          {
            description: `Чебурашка не курит`,
            open: false
          },
          {
            description: `Умею играть в игры`,
            open: false
          },
          {
            description: `Колбаса не расказывает сказки`,
            open: false
          },
          {
            description: `Скакалка не умеет скакать`,
            open: false
          },        
        ],
        active: 0
      }
    },
    components: {
      TabLen,
      Form
    },
    methods: {
      addTab(elem){
        this.tabs.push(elem);
      }
    }
  }
  */
  </script>

  <!--
    ВНИМАНИЕ!!! Если ранее из обекта мы брали данные для какогото html елемента,
    то если мы изменим эти данные то они сразуже изменятьсяя в реальном времени 
    и в html елементе
  -->
























    !!!!              Условия v-if

    Для отрисовки блока по условию используется директива v-if. Блок 
    будет отображаться только в случае, если выражение директивы возвращает 
    значение, которое приводится к true.
    <!-- Тег h1 будет отображаться только если условия v-if будет возвращать true,
    естественно дочерние елементы этого блока также не отображаться если родительского
     блока не будет -->
    <h1 v-if="awesome">Vue восхитителен!</h1>


    Также можно добавить блок «иначе», используя директиву v-else:
    <!--
      В случае если не будет возвращено true в операторе то выведеться тег с v-else
    -->
    <h1 v-if="awesome">Vue восхитителен!</h1>
    <h1 v-else>О, нет 😢</h1>
    <!--
      ВНИМАНИЕ: Элемент с директивой v-else должен следовать сразу за элементом
      с директивой v-if или v-else-if — иначе он не будет распознан.
    -->


    Как следует из названия, v-else-if служит в качестве блока «else if» 
    директивы v-if. Её можно использовать для создания цепочек из условий:
    <!--
      v-esle-if аналогичен if else в javascript, логика работы таже самая
    -->
    <div v-if="Blank.length == 2">
      A
    </div>
    <div v-else-if="Blank.length == 3">
      B
    </div>
    <div v-else-if="Blank.length == 4">
      C
    </div>
    <div v-else>
      Точно не A, B или C
    </div>
















    !!!                     Метод Watch

    (Кароче этот метод работает как addEventListener(`change`))
    С помощью API параметров мы можем использовать watch параметр для запуска функции
    при изменении реактивного свойства:

    <select v-model="filter">
      <option value="one">Адин</option>
      <option value="two">Два</option>
      <option value="three">Три</option>
    </select>
    <script>
      /*
      export default {
        name: 'App',
        data(){
          return {
            blank: [
              {
                name: `Шалон`,
                age: `45`,
                city: `Леопольд`,
                father: `Джигурда`
              }
            ],
            // Переменная которая будет содержать дефолтное значения value в списке
            filter: "two"
          }
        },
        // Этот метод при изминении динамический елементов таких как список отслеживает
        // их и выводит значения выбранное
        watch: {
          filter(value){
            console.log(value)
          }
        },
        components: {
          Blank,
          Form
        },


      }
      */
    </script>







    !!!             ИНТЕРПОЛЯЦИЯ ВО VUE.JS 3

    <!--
      Интерполяция {{}} - это письменные двойные скобки справа и слева 
      в которые мы вставляем наш код или данные которые нужно исполнить 
      или вывести на екран {{}}. НО! мы не можем спомощю интерполяции
      передавать в атрибуты значения, для этого уже нужно использовать v-bind
    -->




                  РАБОТАЕМ СО VUE.JS 3 ЧЕРЕЗ CDN
  !!!!             Метод Date()

  <!-- 
    Этот метод служить для того чтобе мы создавали опеределенные данные 
    при работе с Vue.js. В этом методе мы должны вернуть обект, и уже внутри
    этого обекта мы перечисляем те данные которые должны быть ведны в шаблоне
   -->
  <!-- Подключаем Vue -->
  <script src="https://unpkg.com/vue@next"></script>
  <script>

    // Метод CreateApp принимает в себя обект где мы можем настраивать наше приложения
    let app = Vue.createApp({
      /*
        Для того чтобе из javascript передать какието данные в html - существует
         метод date(). В этом методе мы должны вернуть обект, и уже внутри этого обекта
        мы перечисляем те данные которые должны быть ведны в шаблоне
      */ 
      data(){
        return {
          counter: 0
        }
      }
    })

    // Сюда мы передаем родительский елемент который хотим подключить к Vue.js
    app.mount("#lol");
  
  </script>










  !!!     Слушатели событий во Vue.js 3

  <!--
    События во Vue.js 3 намного легче, удобней и понятней чем в 
    обычном js. Чтобе применить события например click к какомуто 
    html елементу - нам достаточно написать в его теге @click=""
    где в скобках мы пишем действия которое хотим чтобе выполнилось
    по отношеныю к данным которые находяться в методе date(), или же 
    вызвать метод 
  -->

  <div class="container" id="lol">
    <div class="row">
      <div class="col-lg-12 test">
         Счетчик {{ counter }}
      </div>
      <div class="col-lg-12 test">
        <!-- Добавляем и отнимаем единицу от переменной counter при нажатии на кнопку -->
        <button @click="counter++">Добавить</button>
        <button @click="counter--">Отнять</button>
      </div>
    </div>
  </div>














  !!!         ДИРЕКТИВА V-BIND

  <!--
    Если мы хотим записать обект из date() в html атрибут то используем v-bind.
    Он нужен чтобе записывать нашы данные из метода date() в атрибуты
  -->
  <input type="text" v-bind:placeholder="text">




  !!! ОБРАЩЕНИЯ К МЕТОДУ DATA()

  <!--
    Если мы создаем метод и хотим обратиться к базе данных date() то нам 
    нужно прописать ключевое слово this. перед тем как обратиться к одному из обектов
  -->

  <div class="counter">{{ counter }}</div>
  <button @click="changeValue(); counter++">Добавить к счетчику</button>

  <script>
    Vue.createApp({
      data(){
        return {
          counter: 0
        }
      },
      methods: {
        changeValue(){
          // Обращаемся к ключу counter в нашей функции data()
          console.log(this.counter)
        }
      }
    }).mount("#lol");
  </script>








!!!                   СОЗДАНИЯ ЦИКЛА v-for

<!--

  Для того чтобе перебирать елементы в массиве мы указиваем тоже и 
  ванильном javascript только перед for ставим "v" - v-for
  А дальше уже спомощю интерпритации выводим перебираемый елемент в цикле

-->
<div v-for="elem of mes">{{ elem.text }}</div>
<script>
  Vue.createApp({
    data(){
      return {
        mes: [
          {
            text: `Лол`
          },
          {
            text: `Кек`
          },
          {
            text: `Кавик`
          }                        
        ]
      }
    }
  }).mount("#lol");
</script>








!!!           ВЫВОД ИНДЕКСА ПЕРЕБИРАЕМОГО ЕЛЕМЕНТА В ЦИКЛЕ

<!--
  Для того чтобе еще выводить индекс перебираемого елемента в массиве, 
  нужно создать для индекса вторую переменную. Для этого нужно взять переменную 
  елемента в круглые скобки, а также добавить вторую переменную которая и 
  будет являться индексом текущего перебираемого елемента
-->

<div class="col-lg-12 test">
  <!--
    lol - это индекс текущего перебираемого елемента
  -->
  <div v-for="(elem, lol) of mes">{{ elem.text }} Индекс: {{ lol }}</div>
</div>







!!!          ПЕРЕДАЧА ИВЕНТ ЕЛЕМЕНТА КАК АРГУМЕНТ ФУНКЦИИ $event
<!--
  Допустим мы вызиваем функцию в какомто елементе, и мы хотим посмотреть 
  спомощю console.log(event) уже сам елемент в методе - у нас это не получиться 
  сделать. Но если мы хотим также и ивент посмотреть елемента в котором 
  была вызвана функция в его аргументах нужно прописать $event - test(#event).
  Где в самом методе мы уже будем считывать его как обичьную функциию
-->
<div v-for="(elem, lol) of mes">
  <button @click="action($event)">{{elem.text}}</button>
</div>
<script>
  Vue.createApp({
    data(){
      return {
      }
    },
    methods: {
      action(event){
        console.log(event);
      }
    }
  }).mount("#lol");
</script>






!!!         КАК ПОЛУЧИТЬ ИНДЕКС ЕЛЕМЕНТА В МАССИВЕ В CLI
<!--
  Как мы знаем - если использовать vue.js на клиенте - не нужно указывать ключ 
  перебираемого елемента, а вот на бекенде нужно. но вот ключом - нужно указывать 
  названия индекса, или в ином случае будет ошыбка.
-->

<template>
  <div class="items">
    <div  v-for="(todo, index) in items" :key="index.id" class="item">
      <div class="items__name"> {{ index }}</div>
      <button @click="$emit(`remove`)">Удалить</button>
    </div>
  </div>
</template>

<script>
  Vue.createApp({
    data(){
      return {
        props: [`items`]
      }
    }
  })
</script>








!!!             КОРОТКАЯ ЗАПИСЬ V-BIND
<!--
  Для того чтобе например поставить переменную в placeholder и в другие атрибуты 
  мы пишем - v-bind:placeholder="lol", то теперь достаточно писать :placeholder="lol"
-->
<template>
  <input @keypress.enter="add($event)" :placeholder="place" type="text" class="add">
</template>
<script>
  Vue.createApp({
    methods: {
      add(event){
       this.$emit(`add`, event)
      }
    },
    data(){
      return {
        place: `Введите сюда свой текст`
      }
    }
  }) 
  </script>







!!!!!          ВЫЗОВ МЕТОДА СПОМОЩЮ ИНТЕРПОЛЯЦИИ
<!--
  Мы можем в любом участке кода вызивать методы свои спомощю интерполяции {{}}
  Достаточно всего вписать туда свой метод
-->
<div class="counts">
  <div class="counts__count">
   Количество записей:  {{ items.length }}
  </div>
  <div class="counts__x2">
    <!-- Здесь мы вызиваем метод x2 который вернет нам кое что -->
    Записей умноженых на x2: {{ x2(items) }}
  </div>
</div>

<script>
  Vue.createApp({
    props: ["items"],
    methods: {
      add(event){
       this.$emit(`add`, event)
      },
      x2(count){
        return count.length * 2
      }
    },
    data(){
      return {
        place: `Введите сюда свой текст`
      }
    }
  })
  </script>









!!!                     Свойство Watch
<!--
  Может следить за изминениями любых переменных которых захотим.
  Типа например если в переменной helloy= `1` сделать при переключении 
  кнопки смешу ее содержимого на helloy=`2` то соответсвенно вызоветься 
  метод в watch который отслеживает изминения в этой переменной.
  ВНИМАНИЕ: добавления обектов в массив метод watch не отслеживает,
  а если это будет число или строка - то отслеживает запросто
-->

<template>
  <input @keypress.enter="changeText($event)" type="text">
</template>

<script>
  Vue.createApp(
      {
      data(){
        return {
          text: `Простой себе текст`
        }
      },
      watch: {
        // Названия метода должно быть идентично переменной за которой мы будем следить
        text(value){
          console.log(value);
        }
      },
      methods: {
        changeText(event){
          this.text = event.target.value;
        }
      }
    }
  )
</script>









!!!             Атрибут v-modal
<!--
  Этот атрибут позволяет таписывать значения переменных в такие теги 
  как input или textarea
-->
<template>
  <!-- Также, если в теге вручную написать чтото другое то оно измениться 
  и в самой переменной, а также измениться во всех тегах в которых была записа-
  нная данная переменная. -->
  <input v-model="text" type="text">
  <textarea v-model="text" cols="30" rows="10"></textarea>
</template>

<script>
  Vue.createApp({
    data(){
      return {
        text: `Простой себе текст`
      }
    },
    watch: {
      text(value){
        console.log(value);
      }
    },
    methods: {
      changeText(event){
        this.text = event.target.value;
      }
    }
  })
  </script>






!!!              СТИЛИ V-BIND:STYLE="{}"
<!---
  Работа со стилями во vue.js может осуществляться еще спомощю v-bind кроми 
  document.querySelector который не желательно использовать в vue.js. 
  стили мы записываем внутри style="{}" где скобки это обектт, а свойства 
  будут ключами ({width: `50%`}, backgroundColor="red") типа этого. 
-->
<template>
    <input v-model="text" type="text">
    <!-- используем краткую запись v-bind:style - :style -->
    <div :style="{
      -- Присваиваю цвет из переменной myColor
      color: myColor,
      -- Получаю названия фона из метода background()
      backgroundColor: background(),
      -- Записываю на прямую настройки свойства
      fontSize: `24px`,
      borderStyle: `solid`,
      -- Беру размер отступа из метода
      padding: `${proverka()}%`,
      marginTop: `1%`
    }"> {{ text }} </div>
</template>

<script>
  Vue.createApp({
    data(){
      return{
        text: `Лол`,
        myColor: `orange`
      }
    },
    methods: {
      // Возвращаю двойку
      proverka(){
          return 2
      },
      // Смотрю сколько уже написанно в input букв и исходя из этого возвращаю
      // опеределенный цвет
      background(){
        if(this.text.length > 5){
          return `pink`;
        } else {
          return `white`;
        }
      }
    }
  }) 
  </script>








!!!             ДИНАМИЧЕСКИЙ АТРИБУТ :class=""
<!--
  Чтобе можна было динамически работать с атрибутом class нужно 
  его забайндить v-bind:class а если скороченно то :class.
  Существует три способа сделать динамические классы
-->
  1. Первый способ - единичнаяя запись
  <template>
    <div  :class="count == 0 ? `rainbow` : `black`"></div>
  </template>
  
  <script>
    Vue.createApp({
      props: ["count"]
    })
  </script>
  
  <style lang="less" scoped>
    .rainbow{
      margin-top: 5%;
      height: 5vw;
      background-color: grey;
    }
    .black{
      background-color: black;
      margin-top: 5%;
      height: 5vw;
    }
  </style>  
  2. Второй способ - добавления ключей в обект (такой же как и со :style токо здесь возвращають нужно true или false)
  <template>
    <div  :class="{
      rainbow: count == 0,
      black: count == 1,
      bor: true
    }"></div>
  </template>
  
  <script>
    Vue.createApp({
      props: ["count"]
    })
  </script>
  
  <style lang="less" scoped>
    .rainbow{
      margin-top: 5%;
      height: 5vw;
      background-color: grey;
    }
    .black{
      background-color: black;
      margin-top: 5%;
      height: 5vw;
    }
    .bor{
      border-color:aqua;
      border-style: solid;
    }
  </style>

  3. Третий способ - массив с простыми классами в перемешку с обектами

  <template>
    <div  :class="[`bor`, {rainbow: count == 0, black: count == 1}]"></div>
  </template>
  
  <script>
    Vue.createApp({
      props: ["count"]
    }) 
  </script>
  
  <style lang="less" scoped>
    .rainbow{
      margin-top: 5%;
      height: 5vw;
      background-color: grey;
    }
    .black{
      background-color: black;
      margin-top: 5%;
      height: 5vw;
    }
    .bor{
      border-color:aqua;
      border-style: solid;
    }
  </style>  







!!!     ЗАМЕНА ИНТЕРПОЛЯЦИИ {{}} НА ДИРЕКТИВУ V-TEXT=""
<!--
  Вообщем если мы не хотим вставлять интерполяцию спомощю {{}} скобок с тег 
  то мы можем вставлять текст из переменной спомощю директивы v-text=""
-->
<template>
  <div v-text="count"></div>
</template>

<script>
  Vue.createApp({
    props: ["count"]
  })
</script>







!!!              ДИРЕКТИВА v-once
<!--
  Выводит всеголиш адин раз содержимое нашей перееменной или нашего контента
  и в случае если переменная или контент будет изменяться то эта деректива не 
  будет опять изменять содержимое интерполяции в своем теге ибо она только 
  адин раз выводит контент
-->
<template>
  <div v-once>{{ count }}</div>
</template>
<script>
  Vue.createApp({
    props: ["count"]
  })
</script>






!!!              ДИРЕКТИВА v-pre 
<!--
  Она означает что если эту директиву вписать в тег то если мы захотим 
  не использовать интерполяцию в данном теге то ано и не будет ее использоваться
  если вписать данную директиву
-->
<template>
  <div v-pre>{{ count }}</div>
</template>
<script>
  Vue.createApp({
    props: ["count"]
  })
</script>



!!!               ДИРЕКТИВА v-html 
<!--
  Чтобе вставить html код мы используем директиву v-html=""
-->
<template>
  <div v-html="lol"></div>
</template>

<script>
  Vue.createApp({
    props: ["count"],
    data(){
      return {
        lol: `<h1>Тут типа html тег добавился</h1>`
      }
    }
  })
</script>





!!!              ДИРЕКТИВА v-show
<!--
  В общем если вкратце - то v-if скривает елемент из DOM дерева если условия 
  не равно true, а вот директива v-show оставляет елемент в DOM дереве и скривает 
  его спомощю display: none;
-->
<template>
  <div v-show="count > 0">Счетчик больше нуля</div>
</template>

<script>
  Vue.create( {
    props: ["count"]
  })
</script>
<!--
  ПРИМИНЕНИЯ НА ПРАКТИКЕ -
  Например мы циклом выводим все картинки но хотим чтобе показыывался картинка под 
  определенным индексом в массиве, если мы будем использовать v-if то нас будет
  перетаскивать наверх страницы каждый раз при загрузке новой картинке. Но вот если 
  мы укажем v-show который изначально загружает все html елементы с картинками вот 
  только скривает их - то пользователя не будет перекидывать наверх страницы и все 
  будет работать так как и задуманно.
-->







!!!            РАБОТА С СЫЛКАМИ ref=""
<!--
  Вообщем это способ создания переменный в директории this.$refs где будет 
  храниться наш обект которому мы присвоем ref. Так типа мы можем получать елемент
  в динамическими значениями если мы не хотим использовать $event или v-model
-->
<template>
  <div class="counter">
    <div class="counter__left">
      <!-- Чтобе оставить ссылку на елемент пишем ref="названия ссылки" -->
      <input type="text" @keypress="newLet" ref="lalka">
    </div>
  </div>
</template>
<script>
  Vue.createApp({
    methods: {
      newLet(){
        // Чтобе посмотреть все ссылки в директории refs нам нужно прописать this.$refs
       console.log(this.$refs.lalka.value)
      }
    }
  })
  </script>





!!!              Передача атрибутов в теги HTML спомощю Vue.js 
<!--
  Допустим у нас возникла ситуацыя что нужно записать в атрибут src тега img 
  путь к картинке, но записать его нужно из базы данных или перебираемого 
  елемента массива, если вставить интерполяцию {{}} то нихрена кроми скобок не 
  выведеться. Но вот если написать перед атрибутов v-bind:src="test" то 
  все прекрасно заработает.
-->
  <img v-bind:src="elem.src" alt="товар">







!!!           Роутинг страниц спомощю vue-router@4
<!--
  Для начала нужно установить данный модуль
  npm install vue-router@4

  1. Создаем файл router.js в папке src
  2. Записываем настройки в router.js
-->  

<script>
  // Создаем обект createRouter и createWebHashHistroy
  import { createRouter, createWebHashHistory } from "vue-router";
  // Подключаем нашы страницы
  import One from "./components/TheOne.vue"
  import Def from "./components/TheDef.vue"
/*
  // Настройки мы будем записывать в обект createRouter
  export default createRouter({
    // Здесь мы сможем посмотреть историю роутинга
    history: createWebHashHistory(),
    // А здесь собственно мы и настраиваем все роуты
    routes: [
      // Переход по GET запросу /one переведет нас на страницу TheOne.vue
      { path: `/one`, component: One },
      // Просто переход на наш сайт переведет на страницу TheDef.vue
      { path: `/`, component: Def }
    ]
  })
  */
</script>

  <!-- 3. В файле main.js нам нужно добавить наш router -->
  <script>
    import { createApp } from 'vue'
    import App from './App.vue'
    // Здесь сам роут подключаем
    import router from './router';



    let jek = createApp(App)
    // А здесь мы подключаем наш роутинг к самому приложению,
    // он будет работать как middleware
    jek.use(router);
    jek.mount('#app')
  </script>


  <!-- 4. Подключения роута в сам html код в главном файле App.vue -->
  <template>
    <div id="app">
      <!-- В теге router-view будут содержаться нашы страницы -->
      <router-view></router-view>
    </div>
  </template>






  
!!!           ОБЩИЙ ДОСТУП В БАЗЕ ДАННЫХ СПОМОЩЮ МОДУЛЮ vuex
<!--
  Данный модуль нам позволит не писать паравозы из props где мы передаем данные 
  между файлами в иерархии то вниз то вверх - что очень удобно и економно по временни.

  1. Устанавливаем модуль npm install vuex@next
  2. Создаем файл store.js в директории /src
  3. Вносим настройки в файл store и создаем базу данных
-->  
<script>
  import { createStore } from "vuex"

  // Это наша база данных, только здесь вместо дефолтного data()
  // мы вписываем state() а дальше работаем как и с data()
  // Чтобе получить доступ из файла какогото сюда то пишем $store.state.count
  // А еслиже это js код то this.$store.state.count
  let store = createStore({
    state() {
      return {
        count: 0
      }
    }
  })

  // export default store
</script>

  <!-- 4. Регистрируем наш модуль и подключаем в main.js -->
  <script>
    import { createApp } from 'vue'
    import App from './App.vue'
    import router from './router';
    // Подключаем наш модуль c настройками
    import store from "./store";



    let joni = createApp(App)
    joni.use(router);
    // Подключаем модуль к серверу
    joni.use(store);
    joni.mount('#app')
  </script>

  <!-- Доступ к базе данных из любого файла -->
  <template>
    <div class="kek">
      <h1>Это типа дефолтная страница</h1>
      <p>Вывожу данные счетчика - {{ $store.state.count }}</p>
      <button @click="$store.state.count++">Увеличить</button>
    </div>
  </template>







!!!       ПОДКЛЮЧЕНИЯ ФАЙЛА CSS СТИЛЕЙ 
<!--
  Для этого нам потребуеться в папке assets создать наш файл со стилями
  а в главной файле App.vue прописать @import url("@/assets/materialize.min.css");
-->  
<style lang="less">
  @import url("@/assets/materialize.min.css");
</style>


!!!     ПОДКЛЮЧАЕМ JS ФАЙЛЫ К ПРОЕКТУ 
<!--
  Для этого нам потребуеться в папке assets создать наш файл с скриптом
  а в файле main.js прописать путь к нему import "@/assets/test"
-->
<script>
  // Не указывать разрешения файла
  import "@/assets/test"
</script>



!!!         СТРРАНИЦЫ В LAYOUTS
<!--
  Вообщем это типа чтото шаблонизатора, когда главный файл main.hbs в папке 
  layouts это главный файл а в середине в нем подключаюцца страницы,
  а здесь мы можем создавать кучу файлов типа main.hbs для нашый страниц.

  1. Создаем папку layouts в директории /src
  2. Создаем наш файл layout в папке layoust
  3. Записываем html код в него
-->
<template>
  <div class="background">
    Это логин типа
    <!-- Внутри этого layout файла будет загружаться наша страница .vue -->
    <router-view/>
  </div>
</template>

<style scoped>
  .background{
    border-style: solid;
  }
</style>

<script>
Vue.createApp({
    default: {
    name: `login`
  }
}) 
</script>

<!-- 4. Создаем папку views -->
<!-- 5. В папке views создаем нашу страницу с разширениям .vue -->
<!-- 6. Вписываем код в страницу -->
<template>
  <h1>Это страница логина</h1>
</template>


<!-- Прописываем нашу страницу в файле router.js -->
<script>
  Vue.createApp({
    export: createRouter({
  history: createWebHashHistory(),
  routes: [
    {
      path: `/`,
      name: `glav`,
      component: Imp
    },
    {
      path: `/reg`,
      // Здесь мы указываем name который мы установили в страницу JoniLayout
      // ВНИМАНИЕ!!!! Если мы задаем адин и тот же layout двум и более компонентам то `name` в файле router должно у них отличаться
      name: `register`,
      // Названия лай аута должно соответствовать названию компонента в App.vue.
      // Если назовем переменную import BemLayout from "@/layouts/JoniLayout.vue"
      // то переменная в meta должна называаться bem или BemLayout так как 
      // мы добавляем к `bem` строку `layout` то у нас и получаеться названия нашей 
      // переменной 
      meta: {layout: `loli`},
      // А здесь указываем нашу страницу которую нужно загружать в наш layout
      component: ()=> import(`@/views/TheRegister.vue`)
    },  
    {
      path: `/log`,
      // ВНИМАНИЕ!!!! Если мы задаем адин и тот же layout двум и более компонентам то `name` в файле router должно у них отличаться
      name: `login`,
      // Названия лай аута должно соответствовать названию компонента в App.vue.
      // Если назовем переменную import BemLayout from "@/layouts/JoniLayout.vue"
      // то переменная в meta должна называаться bem или BemLayout так как 
      // мы добавляем к `bem` строку `layout` то у нас и получаеться названия нашей 
      // переменной 
      meta: {layout: `bem`},
      component: ()=> import(`@/views/TheLogin.vue`)
    }
  ]
})
  })

</script>

<!-- 7. Подключаем наш layous к App.vue -->
<template>

  <div id="app">
    <div class="content">
      <component :is="layout">
        <!-- Сюда будет вписываться наш layout а в сам layout уже наша страница -->
        <router-view/>
      </component>
    </div>
  </div>
</template>
<script>
import BemLayout from "@/layouts/JoniLayout.vue"
import LoliLayout from "@/layouts/KekLayout.vue"

Vue.createApp({
  name: 'App',
  computed: {
    layout(){
      console.log(this.$route.meta)
    //   return (this.$route.meta.layout) + `-layout`
    return (this.$route.meta.layout) + `-layout`
    }
  },
  components: {
    // Названия переменный должный совпадать с названиям layout в meta
    LoliLayout,
    BemLayout
    
  }
})
</script>






!!!                                 router-link   ДИНАМИЧЕСКИЙ ПЕРЕХОД НА СТРАНИЦУ БЕЗ ЕЕ перезагрузки
<!--
  Динамический переход на другую страницу без ее перезагрузки спомощю тега router-link.
  В котором входной параметрр `to` определяет url для перехода
  <router-link> по умолчанию отображаеться тегом <a>.
  1. Также там не нужно писать хеши /#/ когда указываем get запрос.
  Также перехватываеться события click чтобе браузер не смог перезагрузить страницу
-->
<router-link to="/news">Новости</router-link>

<!--
  А еще можна спомощю javascript также динамически без перезагрузки страницы перенаправлять пользователя.
-->
<li>
  <div @click="page" class="red white-text btn">Переход на страницу</div>
</li>

<script>
  Vue.createApp({
    methods: {
    page(){
      // Мы переходем на страницу /news и здесь также не нужно писать хещ /#/
        this.$router.push(`/news`)
      }
    }
  })
</script>






!!!               СВОЙСТВО ХУК mounted запускает скрпты в себе уже после загрузки DOM елементов
<!--
  Типа если нам нужно работать с елементами или скриптом который должен взаимодествовать после того как полностю 
  загрузить DOM дерево то нам нужно использовать метод mounted
-->
<script>
  Vue.createApp({
    // Все что мы впишем в функции mounted будет исполняться уже после того как загрузиться DOM дерево
    mounted(){
      M.AutoInit();
      console.log(`Это сообщения вызвалось когда уже загрузилось DOM дерево`)
    }
  })
</script>






!!!                    ФОРМАТИРОВАНИЯ ДАТЫ И ВРЕМЕНИ (ВАНИЛЬНЫЙ JAVASCRIPT)
<script>
  let time = new Date();
  /*
   Спомощю метода Intl.DateTimeFormat можна легко и быстро сгенерировать текущее время в нужном мне формате

   new Intl.DateTimeFormat(`ru-RU`).format(time);
   - 28.06.2022

   Также можна указывать настройки для форматирования даты.
   В середине обекта мы указываем в каком порядке будут располагаться дата или время  
   
   new Intl.DateTimeFormat(`ru-RU`,
   {
     day: `numeric`,
     month: `numeric`,
     year: `numeric`,
     hour: `numeric`,
     minute: `numeric`,
     second: `numeric`
   }
   ).format(time);
   - 28.06.2022, 14:49:55


   new Intl.DateTimeFormat(`ru-RU`,
   {
     day: `numeric`,
     month: `long`, // long (название месяца), numeric (номер месяца)
     year: `numeric`,
     hour: `numeric`,
     minute: `numeric`,
     second: `numeric`
   }
   ).format(time);    
   - 28 июня 2022 г., 14:51:12

  */

  let editTime = new Intl.DateTimeFormat(`ru-RU`,
   {
     day: `numeric`,
     month: `long`, // long (название месяца), numeric (номер месяца)
     year: `numeric`,
     hour: `numeric`,
     minute: `numeric`,
     second: `numeric`
   }
   ).format(time);
  console.log(editTime)
</script>











!!!                            ПОДКЛЮЧЕНИЕ БИБЛИОТЕКИ MATERIALIZE К VUE.JS 3
<!--
  Для начала скажу пару слов о том что js файлы подключаюцца к проекту vue.js в файле main.js
  Но если говорить о materialize.js то его нужно устанавливать через npm пакет и после чего 
  в файле main.js уже подключать его
-->
<script>
  // Подключаем js файл
  import "materialize-css"
  // Подключаем css файл
  import "materialize-css/dist/css/materialize.css"
</script>
<!-- А также нужно подключить js файл в самом нашем компоненте, ибо оно не видит обект "M" -->
<script>
  // Подключаем js от materialize
  /* Поскольку materialize не являеться плагином vue.js то обект "M" он не будет видеть
  поэтому нам нужно испортировать js файл с обектом "M"  */
  import M from "materialize-css"
  Vue.createApp({
    mounted() {
      // Инициализируем весь js код.
      // Это значит что нам не прийдеться больше писать какой либо код относящигося к materialize.js
       M.AutoInit();
    }
  })
</script>









!!!                                       ХУК ЖЫЗНЕНОГО ЦЫКЛА beforeUnmount и УТЕЧКА ПАМЯТИ
<!--
  Удаляет слушатели события и наблюдателей.
  Хук beforeUnmount исполняеться тогда - когда мы переходем из страницы на которой был beforeUnmount.
  Обработчики событий будут сами очищяться после их уничтожения.
  В общем если мы поставим в какомто компоненте setInterval и он например будет счетчиком,
  то при переходе на другую страницу в роутах - он продолжыть интервал, так как во vue.js страницы реактивно динамические
  интервал никуда не пропадет и продолжыт идти. И вот мы опять например переходим на страницу где setInterval стоит и у нас 
  запускаеться еще адин setInterval + первый setInterval который не был завершон (так как страница не перезагружалась) и так далее...
  в сумме мы вызиваем кучу setInterval и делаим тем самым утечку памяти на нахрен не нужный уже setInterval. Но мы можем спомощю 
  хука beforeUnmount его убрать при уходе с роута на котором он был.
-->
<template>
  <div class="container">
    <div class="row">
      <div class="card-panel">Счетсик интервала {{ count }}</div>
    </div>
  </div>
</template>

<script>

import M from "materialize-css"
Vue.createApp({
  name: `kek`,
  data(){
    return {
      count: 0,
      // в ключе inverval мы будем записывать сам создаваемый интервал чтобе иметь возможность потом его убрать
      interval: null
    }
  },
  mounted(){
    M.AutoInit();

    // Создаем обработчик события click на окно
    window.addEventListener(`click`, this.mClick, false)

    console.log(`Это сообщения вызвалось когда уже загрузилось DOM дерево`)
    // После загрузки DOM дерева страницы запускаеться сам interval в ключе interval
    this.interval = setInterval(() => {
      this.count++;
      console.log(`ИНТЕРВАЛ РАБОТАЕТ`)
    }, 1000);
  },
  methods: {
    mClick(){
      console.log(`Обработчик события при клике на чтото на екране`)
    }
  },
  // После того как уходим на другой роут с этого то запуститься код в beforeUnmount
  beforeUnmount () {
    console.log(`Это сообщения вызиваеться при уходе из страницы на которой метод beforeUnmount`);
    // Очищяем наш interval
    clearInterval(this.interval);

    // Удаляем обработчик события click на окно
    window.removeEventListener(`click`, this.mClick, false)
  }
})
/* Таким способом я устраняю возникновения утечки памяти  */

</script>








!!!              Модуль vuelidate во vue.js
<!--
  Валидация полей формы спомощю модуля vuelidate.
  ВНИМАНИЕ: ЧТОБЕ ЕГО УСТАНОВИТЬ НУЖНО ИСПОЛЬЗОВАТЬ КОМАНДУ 
  npm install "@vuelidate/core" "@vuelidate/validators"
  А ТАКЖЕ НУЖНО ЧТОБЕ БЫЛ ИНТЕРНЕТ НОМАРЛЬНЫЙ АТО ОНО ЧЕРЕЗ ПЛОХОЙ ИНТЕРНЕТ НЕ СМОЖЕТ СКАЧАТЬ

  Для того чтобе подключить в файл наш шаблон пишем следующее -
-->
<template>
  <div class="container">
    <h4>Форма валидации</h4>
    <div class="row">
      <!--
        Отменяем перезагрузку формы, а также вызиваем метод submitButton
      -->
      <form action="" method="post" @submit.prevent="submitButton">
        <div class="input-field col s6">
          <!-- Здесь спомощю директивы v-bind проверяем - не видает ли ошибок name ? v$.name.$error.
            Если ошибок нету то мы ставим клас успешной валидации поля. !v$.name.$error
           -->
          <input v-model="name" placeholder="Name" id="first_name" type="text" 
           :class="{invalid: v$.name.$error, validate: !v$.name.$error}"
           @keypress="v$.name.$validate()"
          >
          <!-- Если у нас будет клас invalid в input то выведеться сообщения из data-error,
            также и с data-success - только если будет клас validate в input
           -->
         <span class="helper-text" data-error="Введите одну букву" data-success="right"></span>
        </div>
        <div class="input-field col s6">
          <input v-model="login" name="login" placeholder="Login" id="first_name" type="text"
           :class="{invalid: v$.login.$error, validate: !v$.login.$error}"
          @keypress="v$.login.$validate()"
           >
          <span class="helper-text" data-error="Текст должен содержать минимум 6 символов" data-success="right"></span>
        </div>
        <div class="input-field col s6">
          <input v-model="email" name="email" placeholder="Email" id="first_name" type="email" 
           :class="{invalid: v$.email.$error, validate: !v$.email.$error}"
           @keypress="v$.email.$validate()"
          >
          <span class="helper-text" data-error="Не правельно введен email" data-success="right"></span>
        </div>
        <div class="input-field col s6">
          <input v-model="age" name="age" placeholder="Age" id="first_name" type="number" 
           :class="{invalid: v$.age.$error, validate: !v$.age.$error}"
           @keypress="v$.age.$validate()"
          >
          <span class="helper-text" data-error="Введите число" data-success="right"></span>
        </div>
        <button type="submit" class="btn col l12">Отправить</button>
      </form>
    </div>
  </div>
</template>
<script>

// Подключаем сам validator для vue 3
import useValidate from "@vuelidate/core"
// Нужные нам проверки и валидатора берем
import { required, email, sameAs, minLength} from "@vuelidate/validators"
// required - значение не может быть пустым
// minLength/maxLength– обеспечивает минимальную или максимальную длину для значения
// email - значение должно быть допустимым форматом адреса электронной почты
// alpha - значение принимает только алфавит
// numeric - значение принимает только числа
/*
  sameAs - сравнения с чемто или проверка на наличия определенного значения/строки/значения
      repeatPassword: {
        required, 
        // Здесь мы сравниваем это поле с паролем, если оно не будет ему идентично то проверка не будет пройдена
        sameAs: sameAs(this.password)
      },
*/
import M from "materialize-css"
  Vue.createApp({
  name: `vuelidate`,
  data(){
    return{
      // Подключаем наш валидатор в базе данных
      v$: useValidate(),
      name: ``,
      login: ``,
      email: ``,
      age: ``,
      kek: false
    }
  },  
  validations(){
    return {
      name: {required},
      login: {required, minLength: minLength(6)},
      email: {required, email},
      age: {required}
    }
  },
  methods: {
    submitButton(){
      this.v$.$validate()
      if(!this.v$.$error){
        M.toast({html: 'Успешная валидация полей'})
      } else {
        M.toast({html: 'Не прошло валидацию'})
        // this.v$.$errors - здесь мы можем увидеть какие поля не прошли валидацию
        // this.v$.$errors[0].$propertyPath - увидим названия самого первого поле не просовшего валидацию
        console.log(this.v$.$errors[0].$propertyPath)
      }
    },
    change(){
      console.log(!this.v$.name.$error);
    }
  },
  mounted(){
    M.AutoInit();
    
  }
}) 
</script>









!!!!              middleware проверка в роутерах
<!-- В файле main.js мы можем перед переход на какуюто страницу отправлятть запрос на сервер с сесией и возвращать ответ 
с бекенда которы укажет - можна ли переходить по странице или нет (типа есть ли доступ у него к ней или нет) -->
<script>
  // from - роут с которого переходим
// to - роут на который переходим
router.beforeEach(async (to, from, next) => {
  try{

    await  fetch(`http://localhost:2000/midle`, {
      method: 'GET',
      mode: 'cors',
          headers: {
          'content-type': 'application/json'
      }
      }).then((response)=>{
        // Разпарсиваем полученную JSON строку и передаем в следующий then
        return response.json()
      })
    
      .then((infa)=>{
        // Возвращаем распарсинную информацию в аргументе resolve
        
        // Если мы переходем не на главную страницу
        // Если мы не прошли авторизацию
        // То переходим на главную стрраницу
        if(to.name !== 'imposible' && !infa.res){
          console.log(`НЕ Прошло проверку`)
          next({name: `imposible`});
        } else {
          console.log(`Прошло проверку`);
          next();
        }
      })
 
  } catch(error){
    console.log(error);
  }
})
</script>






!!! ПЕРЕДАЧА СЕССИЙ МЕЖДУ VUE.JS И NODE.JS СЕРВЕРОМ
// Vue.js
<script>
  router.beforeEach(async (to, from, next) => {
  try{

    await  fetch(`http://localhost:3002/getSession`, {
      method: 'GET',
      mode: 'cors',
      headers: {
          'content-type': 'application/json'
      },
      // Здесь пишем так что передавались куки авторизации
      credentials: 'include'
      }).then((response)=>{
        // Разпарсиваем полученную JSON строку и передаем в следующий then
        return response.json()
      })
    
      .then((infa)=>{
        console.log(infa);

        next()
      })
 
  } catch(error){
    console.log(error);
  }
})
</script>

<!--
  Node.js сервер
-->
<script>
  // А здесь в политике cors устанавливаем чтобе можна было принимать куки авторизации из склиента
  app.use(cors({
    // Адрес из которого можна принимать куки авторизации
    origin: 'http://localhost:8080',
    credentials: true
  }));
</script>







!!!         КАК СОБРАТЬ ПРОЕКТ VUE ?
<!--
  Изначально может показаться что мы заливать должны на - сервер vue CLI но это не так
  На самом деле когда проект готов то мы просто прописываем - npm run build и проект собираеться 
  уже как минифицированый со всеми файлами бичьный проект с библиотекой vue. Но это на самом деле 
  очень удобно ибо присутсвуют роуты и модульность
-->








!!!        Модуль Vue Awesome Paginate для пагинации (пагинация страниц)
<!--
  Для начала нужно установить npm i vue-awesome-paginate
  после чего подключить его в файле main.js
-->
<script>
  import { createApp } from 'vue'
  // import Vuelidate from 'vuelidate'
  // import Vuelidate from 'vuelidate'
  import App from './App.vue'
  import router from './router';
  import store from "./store";
  import "materialize-css"
  import "materialize-css/dist/css/materialize.css"

  // import the package
  import VueAwesomePaginate from "vue-awesome-paginate";
  // import the necessary css file
  import "vue-awesome-paginate/dist/style.css";

  let app = createApp(App)
  app.use(VueAwesomePaginate);
  app.use(router);
  app.use(store);
  app.mount('#app')
</script>

<!-- В компонентах создаем файл с нашей пагинацией и внтурри него пишем.. -->
<template>

  <div class="container">
    <div class="row">
      <div v-for="elem of frontBasa" :key="elem" class="card-panel blue white-text">
        <p>{{ elem }}</p>
      </div>
    </div>
  </div>


<!-- 
    :total-items="50" - количество контента в базе данных
    :items-per-page="5" - количество контента загружаемого на одну страницу
    :max-pages-shown="5" - количество видемых страниц для перелистывания (в навигации)
    :current-page="1" - номер загружаемой страницы по дефолту
    :on-click="onClickHandler" - при клике на одну из страниц вызов метода onClickHandler который в аргументе передаст номер страницы
-->
  <vue-awesome-paginate
    :total-items="backBasa.length"
    :items-per-page="itemsPerPage"
    :max-pages-shown="5"
    :current-page="1"
    :on-click="onClickHandler"
  />
</template>

<script>

  Vue.createApp({
    data(){
      return {
        // Бекенд база данных
        backBasa: [
          `Авладакидабра`,
          `Барбос`,
          `Мурзилка`,
          `Хована`,
          `Селафи`,
          `Майами`,
          `Вентура`,
          `Галос`,
          `Канеки`,
          `Улюла`,
          `Хаймос`,
          `Майами`,
          `Minecraft`,
          `Ватсаби`,
          `Хована`,
          `Мишь`
        ],
        // Фронтенд база данных
        frontBasa: [],
        nowPage: 1,
        itemsPerPage: 2
      }
    },
    mounted() {
        for(let i = this.nowPage-1; i < this.nowPage-1 + this.itemsPerPage; i++){
          this.frontBasa.push(this.backBasa[i]);
        }
    },
    methods: {
      // page - номер страницы на которую перешли
      onClickHandler(page){
      // Здеьс кароче мы должны будем отправлять запрос на сервер и получать нужные нам обекты, после чего записыват в frontBasa
        this.nowPage = page;

        this.frontBasa = [];
        for(let i = this.nowPage-1; i < this.nowPage-1 + this.itemsPerPage; i++){
          this.frontBasa.push(this.backBasa[i]);
        }

      }
    }
  })

  
</script>


<style>
  .pagination-container {
    display: flex;
    column-gap: 10px;
  }
  .paginate-buttons {
    height: 40px;
    width: 40px;
    border-radius: 20px;
    cursor: pointer;
    background-color: rgb(242, 242, 242);
    border: 1px solid rgb(217, 217, 217);
    color: black;
  }
  .paginate-buttons:hover {
    background-color: #d8d8d8;
  }
  .active-page {
    background-color: #3498db;
    border: 1px solid #3498db;
    color: white;
  }
  .active-page:hover {
    background-color: #2988c8;
  }
</style>








!!!               ПОДКЛЮЧЕНИЯ ВНЕШНИХ СКРИПТОВ К ПРОЕКТУ VUE.JS И ИСПОЛЬЗОВАНИЯ ИХ МЕТОДОВ
<!--
  Устанавливаю модуль npm install --save vue-plugin-load-script@^2.x.x

  В файле main.js подключаю его
-->
<script>
  import LoadScript from "vue-plugin-load-script";
  app.use(LoadScript);
</script>

<!-- В файле где нам нужно подключить библиотеку -->
<script>
  import { loadScript } from "vue-plugin-load-script";
  loadScript("https://cdnjs.cloudflare.com/ajax/libs/Darkmode.js/1.5.7/darkmode-js.min.js")
    .then(() => {
      // Script is loaded, do something
      new window.Darkmode().showWidget()
    })
    .catch(() => {
      // Failed to fetch script
    });
</script>




!!!       КАК УСТАНОВИТЬ ЯЗЫК LANG В HTML ТЕГЕ ВО VUE ?
<script>
  document.querySelector(`html`).attributes[0].value = `ru`
</script>





!!!    ПОДКЛЮЧЕНИЯ BOOTSTRAP GRID СЕТКИ ВО VUE-3
<!-- Файл main.js -->
<script>
  import { createApp } from 'vue'
  import App from './App.vue'
  // Установка - npm i --save bootstrap bootstrap-vue-3 @popperjs/core
  // Bootstrap для vue-3
  import BootstrapVue3 from 'bootstrap-vue-3'
  // Подключаем bootstrap grid сетку
  import 'bootstrap/dist/css/bootstrap-grid.min.css'
  // Стили Normalaiz.css
  import './normalaiz.css'
  import "materialize-css"
  import "materialize-css/dist/css/materialize.css"
  // Для того чтобе установить иконки нужно npm install material-design-icons --save
  import 'material-design-icons/iconfont/material-icons.css'

  let app2 = createApp(App)
  app2.use(BootstrapVue3)
  app2.mount('#app')
</script>




!!!            КАК ПОЛУЧАТЬ И ОТПРАВЛЯТЬ CSRF ТОКЕН ВО VUE3 ?
<!--
  Алгоритм действий такой - на сервере подключам модуль middleware в файле index.js
-->
<script>
  app.use(sessionMiddleware); // Проверка пользователя на авторизацию
  app.use(csrf()); 
  app.use(csrfMidle)
</script>
<!-- Содержимое файла csrfMidle -->
<script>
  module.exports = function (req,res,next){
    // генерируемм csrf токен и кладем в локальное хранилище
    res.locals.csrf = req.csrfToken();
    next();
  }
</script>
<!-- Содержимое файла sessionMiddleware -->
<script>
  module.exports = function (req,res,next){
    // Если сессия не имеет клюса accept то true
    if(!req.session.accept){
      res.send(JSON.stringify({
        authSession: false,
        csrf: res.locals.csrf
      }))
      console.log(`Пользователь НЕ АВТОРИЗОВАН`)
      return;
    } 
  // console.log(req.session);

    next();
  }
</script>
<!--  
  В файле sessionMiddleware мы отправляем csrf пользователю если он не авторизован.
  В файле main.js во Vue-3 мы в хуке beforEach получаем csrf токен и устанавливаем 
  его в заголовок всех нашых axios сообщений
-->
<script>
  router.beforeEach(async (to, from, next) => {
    try{

      //! Проверка наличия сессии
      await axios.get("http://localhost:3001/checkSession").then((response) => {
        
        // Устанавливаем CSRF токен в заголовок axios
        axios.defaults.headers.common['X-CSRF-TOKEN'] = response.data.csrf;

        // Если пользователь имеет сессию то - true
          if(response.data.user){
            store.state.logout = true;
            console.log(store.state.logout)
          } else {
            store.state.logout = false;
            console.log(store.state.logout)
          }
      })

      next();  
  
    } catch(error){
      console.log(error);
    }
    
  })
</script>
<!--
  ВНИМАНИЕ: При каждом новом обновлении страницы клиент будет получать новый csrf токен от бекенда и класть его в заголовок axios
-->





ХОСТИНГ VERCEL И БЕСПЛАТНАЯ РАБОТА TELEGRAM БОТА
<!--
	https://vercel.com - это бесплатный хостинг для telegram ботов работающих на API "telebot"
	https://www.youtube.com/watch?v=xA25u-WYOAM&t=275s - туториал YOUTUBE по установке бота на площадку

	1. Для начала на своем GITHUB аккаунте установить платформу Vercel.
	 - переходим на страницу https://github.com/apps/vercel
	 - нашимаем на кнопку "Install" 
	2. Регистрируем аккаунт на сайте https://vercel.com (ЕСЛИ НЕ ЗАРЕГИСТРИРОВАНЫ)
	3. Переходим на страницу https://github.com/PonomareVlad/TeleVercelBot
	 - нажимаем кнопку "Deploy"
	4. В блоке "Create Git Repository" выбираем площадкку "Github" 
	 - в поле "GIT SCOPE" выбираем наш github аккаунт
	 - в поле "REPOSITORY NAME" выдумиваем названия нашего репозитория для vercel
	 - нажимаем на кнопку "Create"
	5. В блоке "Configure Project" в поле "VALUE" вписываем ключ нашего телеграм бота
	 - нажимаем кнопку "Deploy"
	6. После перенаправления на новую страницу нажимаем кнопку "Dashbord"
	7. В блоке "Production Deployment" в категории "DOMAINS" переходим по ссилке
	 - нажимаем на кнопку "SetWebHookUrl" 
	8. Чтобе вносить изминения в нашего бота переходим в его репозиторий на github и окончания .com изменяем 
	на .dev и после чего у нас откроеться визуальный редактор Visual Studio Code.

	КАК КОМИТИТЬ СОХРАНЕНИЯ ?
	1. В реадкторе в левой панеле нажимаем на кнопку с тремя кржочками обвязаными ниттю
		- в поисковой строке пишем названия комита
		- нажимаем на кнопку(галочку) 
-->

</body>
</html>